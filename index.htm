<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Free Instagram grid splitter. Split one image into three 1080x1350 (4:5) aligned posts. Prevent Instagram square crop misalignment in your profile grid." />
  <meta name="keywords" content="instagram grid splitter, instagram 3 post grid, instagram 4:5 split, instagram seamless grid tool, instagram crop fix" />
  <title>INSTACUT</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>

  <style>
:root{
  --bg0:#07070b;
  --bg1:#0a0d16;

  --glass: rgba(255,255,255,0.06);
  --glass2: rgba(255,255,255,0.10);
  --stroke: rgba(255,255,255,0.16);
  --ink: rgba(255,255,255,0.92);
  --muted: rgba(255,255,255,0.68);

  --a:#a7cbd9;
  --b:#6faec7;
  --c:#b3ffb3;
  --d:#a88bff;

  --gap: 18px;
}

*{ box-sizing:border-box; }
html, body{ height:100%; }

body{
  margin:0;
  font-family: Arial, sans-serif;
  color: var(--ink);
  background:
    radial-gradient(1200px 700px at 20% 10%, rgba(168,139,255,0.20), transparent 60%),
    radial-gradient(900px 600px at 80% 20%, rgba(167,203,217,0.18), transparent 60%),
    radial-gradient(1000px 700px at 50% 90%, rgba(179,255,179,0.12), transparent 60%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
  overflow: hidden;
}

body::before{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background-image:
    linear-gradient(90deg, rgba(255,255,255,0.015), rgba(255,255,255,0.015)),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 3px);
  mix-blend-mode: overlay;
  opacity: 0.45;
}

#inputLayer{
  position: fixed;
  inset: 0;
  z-index: 9999;
  background: transparent;
  pointer-events: none;
}

.stage{
  position: fixed;
  inset: 0;
  pointer-events: none;
}

/* Title */
.title-top{
  position: absolute;
  left: 50%;
  top: 42%;
  transform: translate(-50%, -50%) translateY(140vh);
  font-size: 17vw;
  font-weight: 900;
  letter-spacing: 0.03em;
  color: rgba(255,255,255,0.05);
  user-select: none;
  line-height: 0.9;
  will-change: transform, opacity;
  z-index: 1;
}

/* Main box */
.content{
  position: absolute;
  left: 50%;
  top: 56%;
  transform: translate(-50%, -50%) translateY(140vh) scale(0.98);
  width: min(980px, 92vw);
  padding: 28px 22px 34px;
  border-radius: 22px;
  background: linear-gradient(180deg, var(--glass2), var(--glass));
  border: 1px solid var(--stroke);
  backdrop-filter: blur(16px);
  will-change: transform, opacity;
  z-index: 3;
  pointer-events: auto;
}

.sigil{
  position: absolute;
  inset: -1px;
  border-radius: 22px;
  pointer-events: none;
  background:
    radial-gradient(600px 140px at 50% 0%, rgba(167,203,217,0.25), transparent 70%),
    radial-gradient(500px 120px at 30% 100%, rgba(168,139,255,0.18), transparent 70%),
    radial-gradient(380px 110px at 80% 85%, rgba(179,255,179,0.10), transparent 70%);
  mask-image: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.15));
  opacity: 0.9;
}

/* Hint */
.scroll-hint{
  position: absolute;
  left: 50%;
  top: 86%;
  transform: translate(-50%, -50%);
  width: 34px;
  height: 34px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  opacity: 0;
  will-change: transform, opacity;
  z-index: 6;
  pointer-events: none;
}
.scroll-hint::before{
  content:"v";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -55%);
  font-weight: 900;
  letter-spacing: 0.02em;
  color: rgba(255,255,255,0.75);
}
@keyframes hintPulse{
  0%   { transform: translate(-50%, -50%) scale(0.95); opacity: 0; }
  16%  { opacity: 0.55; }
  35%  { transform: translate(-50%, -48%) scale(1.02); opacity: 0.85; }
  60%  { transform: translate(-50%, -51%) scale(0.99); opacity: 0.75; }
  100% { transform: translate(-50%, -50%) scale(0.94); opacity: 0; }
}
.scroll-hint.play{ animation: hintPulse 900ms cubic-bezier(.2,.9,.2,1) 1; }

/* Features panel */
.features{
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(180deg, var(--bg1), var(--bg0));
  border-top: 1px solid var(--stroke);
  transform: translateY(140%);
  will-change: transform;
  z-index: 2;
  pointer-events: none;
}

.features-glow{
  position:absolute;
  inset:-1px;
  pointer-events:none;
  background:
    radial-gradient(800px 200px at 50% 0%, rgba(167,203,217,0.15), transparent 70%),
    radial-gradient(600px 180px at 20% 100%, rgba(168,139,255,0.12), transparent 70%),
    radial-gradient(500px 160px at 80% 90%, rgba(179,255,179,0.08), transparent 70%);
  opacity: 0.65;
  transform: translateY(14px);
  will-change: transform, opacity;
}

.features-inner{
  position: relative;
  height: 100%;
  width: 100%;
}

.features-content{
  position: relative;
  max-width: 1000px;
  margin: 0 auto;
  padding: 3.0rem 2rem 2.0rem;
  height: calc(100% - 84px);
  display:flex;
  flex-direction: column;
  justify-content: center;
  z-index: 1;
}

.f-main, .f-grid, .f-keys{
  opacity: 0;
  transform: translateY(26px);
  will-change: transform, opacity;
}

.f-main h2{
  font-size: 1.4rem;
  font-weight: 700;
  margin: 0 0 1rem;
  background: linear-gradient(120deg, var(--a), var(--b), var(--c), var(--d));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  letter-spacing: 0.02em;
}

.f-main p{
  color: var(--muted);
  line-height: 1.7;
  margin: 0 0 2.2rem;
  font-size: 0.95rem;
}

.f-grid{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 2.5rem;
  margin-bottom: 2.2rem;
}

.f-col h3{
  font-size: 0.85rem;
  font-weight: 700;
  color: var(--ink);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin: 0 0 1rem;
  opacity: 0.9;
}

.feature-tag{
  display:inline-block;
  padding: 6px 12px;
  margin: 4px 6px 4px 0;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.04);
  color: var(--muted);
  font-size: 0.85rem;
  transition: transform 180ms ease, background 180ms ease, border-color 180ms ease;
}
.feature-tag:hover{
  border-color: rgba(167,203,217,0.35);
  background: rgba(167,203,217,0.08);
  transform: translateY(-1px);
}

.step{
  padding: 8px 0;
  color: var(--muted);
  font-size: 0.9rem;
  border-bottom: 1px solid rgba(255,255,255,0.06);
}
.step:last-child{ border-bottom: none; }

.f-keys{
  padding: 1.2rem 1.5rem;
  margin: 1.8rem 0 0;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  color: rgba(255,255,255,0.50);
  font-size: 0.8rem;
  line-height: 1.8;
  text-align: center;
}

.fake-footer{
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 84px;
  border-top: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.10);
  display:flex;
  align-items:center;
  justify-content:center;
  padding: 0 16px;

  opacity: 0;
  transform: translateY(12px);
  will-change: transform, opacity;
  pointer-events: auto;
}

.fake-footer-inner{
  width: min(980px, 92vw);
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 14px;
  flex-wrap: wrap;
}

.ff-left{
  font-size: 0.85rem;
  font-weight: 800;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: rgba(255,255,255,0.55);
}

.ff-links{
  display:flex;
  gap: 14px;
  flex-wrap: wrap;
  justify-content:flex-end;
}

.fake-footer a{
  color: rgba(255,255,255,0.85);
  text-decoration: none;
  border-bottom: 1px solid rgba(255,255,255,0.25);
  padding-bottom: 2px;
}
.fake-footer a:hover{
  border-bottom-color: rgba(179,255,179,0.55);
}

/* Tool UI */
.drop-zone{
  position: relative;
  border-radius: 18px;
  padding: 28px 18px;
  margin: 18px auto 10px;
  border: 1px dashed rgba(167,203,217,0.55);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  cursor: pointer;
  overflow: hidden;
}
.drop-zone input[type="file"]{ position:absolute; inset:0; opacity:0; cursor:pointer; }
.drop-hint{ display:grid; gap:10px; justify-items:center; padding:10px 0; }
.drop-hint .kicker{ font-size:0.95rem; color:var(--muted); letter-spacing:0.02em; }
.drop-hint .cta{
  display:inline-flex; align-items:center; gap:10px;
  padding: 12px 18px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,0.14);
  background: linear-gradient(135deg, rgba(167,203,217,0.18), rgba(168,139,255,0.12));
}
.drop-zone.over::before{
  content:'';
  position:absolute; inset:0;
  background:
    radial-gradient(900px 220px at 50% 10%, rgba(179,255,179,0.16), transparent 70%),
    linear-gradient(90deg, transparent, rgba(167,203,217,0.12), transparent);
  animation: sweep 1.1s linear infinite;
  pointer-events:none;
}
@keyframes sweep{
  0%   { transform: translateX(-25%); opacity: 0.55; }
  50%  { transform: translateX(0%);   opacity: 0.80; }
  100% { transform: translateX(25%);  opacity: 0.55; }
}
.drop-zone.over{ border-color: rgba(179,255,179,0.75); }

.zip-button-wrapper{ width:100%; display:flex; justify-content:center; margin-top:14px; }

#downloadButton{
  padding: 12px 18px;
  font-size: 1rem;
  font-weight: 700;
  border: 1px solid rgba(255,255,255,0.16);
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(167,203,217,0.26), rgba(111,174,199,0.18));
  color: var(--ink);
  cursor: pointer;
  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}
#downloadButton:hover{
  transform: translateY(-1px);
  border-color: rgba(167,203,217,0.55);
  background: linear-gradient(135deg, rgba(167,203,217,0.32), rgba(168,139,255,0.16));
}
#downloadButton:disabled{ opacity:0.65; cursor:not-allowed; transform:none; }

#previewContainer{
  position: relative;
  width: min(900px, 92vw);
  margin: 18px auto 10px;
  padding: 14px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  display: none;
  justify-content: center;
  align-items: center;
  gap: 10px;
  overflow: hidden;
}
#previewContainer::after{
  content:'';
  position:absolute;
  inset:0;
  background-image: repeating-linear-gradient(
    -45deg,
    rgba(255,255,255,0.00),
    rgba(255,255,255,0.00) 12px,
    rgba(255,255,255,0.06) 12px,
    rgba(255,255,255,0.06) 18px
  );
  pointer-events:none;
  opacity: 0.45;
}
.preview-tile{
  position: relative;
  display: inline-flex;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  overflow: hidden;
  cursor: pointer;
  user-select: none;
  background: rgba(255,255,255,0.02);
  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}
.preview-tile:hover{
  transform: translateY(-1px);
  border-color: rgba(179,255,179,0.45);
  background: rgba(255,255,255,0.04);
}
.preview-tile::after{
  content: "Download";
  position: absolute;
  right: 10px;
  bottom: 10px;
  font-size: 0.85rem;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(10,13,22,0.55);
  color: rgba(255,255,255,0.90);
  opacity: 0;
  transform: translateY(4px);
  transition: opacity 160ms ease, transform 160ms ease;
  pointer-events: none;
}
.preview-tile:hover::after{ opacity: 1; transform: translateY(0); }
#previewContainer img{ height: 200px; display: block; }

.publish-warning{
  margin: 14px auto 4px;
  padding: 12px 16px;
  border-radius: 14px;
  border: 1px solid rgba(179,255,179,0.35);
  background: linear-gradient(135deg, rgba(179,255,179,0.08), rgba(167,203,217,0.08));
  font-size: 0.9rem;
  line-height: 1.5;
  color: var(--muted);
  text-align: center;
  opacity: 0;
  transform: translateX(-40px);
  transition: transform 400ms cubic-bezier(.2,.9,.2,1), opacity 400ms ease;
}
.publish-warning.show{ opacity: 1; transform: translateX(0); }

.download-container{ width:100%; display:flex; justify-content:center; margin-top:14px; }
.download-link{
  display:inline-flex;
  align-items:center;
  gap:10px;
  padding: 12px 18px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.16);
  text-decoration:none;
  color: var(--ink);
  background: linear-gradient(135deg, rgba(168,139,255,0.18), rgba(167,203,217,0.20));
  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}
.download-link:hover{
  transform: translateY(-1px);
  border-color: rgba(179,255,179,0.50);
  background: linear-gradient(135deg, rgba(179,255,179,0.14), rgba(167,203,217,0.22));
}

.stage{
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 1;
  transition: opacity 0ms linear;
  will-change: opacity;
}


@media (max-width: 768px){
  .features-content{ padding: 2.2rem 1.5rem 1.5rem; height: calc(100% - 92px); }
  .f-main h2{ font-size: 1.2rem; }
  .f-grid{ grid-template-columns: 1fr; gap: 2rem; }
  .fake-footer{ height: 92px; }
  .fake-footer-inner{ justify-content: center; }
  .ff-links{ justify-content: center; }
}
  </style>
</head>

<body>
  <div id="inputLayer" aria-hidden="true"></div>

  <div class="stage">
    <div class="title-top" id="titleTop">INSTACUT</div>

    <div class="content" id="contentBox">
      <div class="sigil"></div>

      <div class="drop-zone" id="dropZone">
        <div class="drop-hint">
          <div class="cta">
            <span>Drop an image here</span>
            <span style="opacity:.7">or click</span>
          </div>
          <div class="kicker">Split into 3 posts (Instagram grid anti-zoom)</div>
        </div>
        <input type="file" id="uploadButton" accept="image/*" />
      </div>

      <div class="zip-button-wrapper">
        <button id="downloadButton" style="display:none;">Generate ZIP</button>
      </div>

      <div id="previewContainer"></div>

      <div class="publish-warning" id="publishWarning">
        ⚠️ Instagram defaults to square, tap ⤢ EXPAND when posting. ⚠️
      </div>

      <div class="download-container" id="downloadContainer"></div>
    </div>

    <div class="scroll-hint" id="scrollHint" aria-hidden="true"></div>

    <div class="features" id="featuresPanel">
      <div class="features-glow" id="featuresGlow"></div>

      <div class="features-inner">
        <div class="features-content">
          <div class="f-main" id="fMain">
            <h2>INSTACUT · Free Instagram Grid Splitter</h2>
            <p>
              Split images into 3 seamless Instagram posts (1080×1350 4:5 tiles).
              Compensates for Instagram's square crop to keep your panoramic grid perfectly aligned.
              No watermark, works 100% in browser, privacy-friendly, and infinite carousel.
            </p>
          </div>

          <div class="f-grid" id="fGrid">
            <div class="f-col">
              <h3>Features</h3>
              <span class="feature-tag">Free panorama splitter</span>
              <span class="feature-tag">infinite carousel</span>
              <span class="feature-tag">3-tile grid layouts</span>
              <span class="feature-tag">Anti-zoom alignment</span>
              <span class="feature-tag">Instant preview</span>
              <span class="feature-tag">ZIP download</span>
              <span class="feature-tag">No upload needed</span>
            </div>

            <div class="f-col">
              <h3>How to Use</h3>
              <div class="step">1. Drop or upload image</div>
              <div class="step">2. Preview 3-panel split</div>
              <div class="step">3. Download tiles/ZIP</div>
              <div class="step">4. Post in 4:5 format</div>
              <div class="step">5. Tap ⤢ Expand on Instagram</div>
            </div>
          </div>

          <div class="f-keys" id="fKeys">
            Instagram grid splitter · panorama splitter · carousel maker · tiled posts ·
            grid layout tool · 3-post panorama · feed planner · seamless grid · Instagram panoramic posts
          </div>
        </div>

        <div class="fake-footer" id="fakeFooter">
          <div class="fake-footer-inner">
            <div class="ff-left">Links</div>
            <div class="ff-links">
              <a href="https://secret-guest.github.io/barcraft/" target="_blank" rel="noopener noreferrer">QR Code generator page</a>
              <a href="https://github.com/SECRET-GUEST" target="_blank" rel="noopener noreferrer">Back to GitHub</a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // ============================================================
  // IMPORTANT FIX
  // ------------------------------------------------------------
  // Your #inputLayer is a full-screen overlay (z-index:9999).
  // If it captures pointer events, it will block ALL clicks/drags.
  //
  // Fix strategy:
  // 1) Make #inputLayer "click-through" in CSS: pointer-events:none
  // 2) Attach scroll/touch listeners to window instead of #inputLayer
  //
  // Add this in CSS:
  //   #inputLayer { pointer-events: none; }
  // ============================================================

  const inputLayer = document.getElementById('inputLayer');

  const titleTop = document.getElementById('titleTop');
  const content = document.getElementById('contentBox');
  const scrollHint = document.getElementById('scrollHint');

  const features = document.getElementById('featuresPanel');
  const featuresGlow = document.getElementById('featuresGlow');

  const fMain = document.getElementById('fMain');
  const fGrid = document.getElementById('fGrid');
  const fKeys = document.getElementById('fKeys');
  const fakeFooter = document.getElementById('fakeFooter');

  const dropZone = document.getElementById('dropZone');
  const uploadButton = document.getElementById('uploadButton');
  const previewContainer = document.getElementById('previewContainer');
  const downloadButton = document.getElementById('downloadButton');
  const downloadContainer = document.getElementById('downloadContainer');
  const publishWarning = document.getElementById('publishWarning');

  // -----------------------------
  // Small math helpers
  // -----------------------------
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function easeInOutCubic(t){ return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

  // -----------------------------
  // Scroll loop length
  // -----------------------------
  let LOOP = 2600;
  function computeLoopLen(){
    const vh = window.innerHeight;
    LOOP = Math.max(2600, Math.round(vh * 3.2));
  }

  // -----------------------------
  // Input tuning
  // -----------------------------
  const WHEEL_SCALE = 0.16;
  const TOUCH_SCALE = 0.20;
  const KEY_STEP    = 85;

  const MAX_IMPULSE = 85;
  const FRICTION    = 0.86; // not used directly (kept for reference)
  const RESPONSE    = 0.82;

  // Virtual scroll position + velocity
  let vScroll = 0;
  let vVel = 0;

  // Hold/warp mapping (progress -> u)
  const HOLD_P_START = 0.70;
  const HOLD_P_END   = 0.78;
  const HOLD_U       = 0.74;

  const CLEANUP_P_START = 0.95;

  // Fade stage near end
  const FADE_P_START = 0.91;
  const FADE_P_END   = 0.95;
  const stageEl = document.querySelector('.stage');

  // -----------------------------
  // Convert scroll position to [0..1] progress
  // -----------------------------
  function pFromScroll(){
    const mod = ((vScroll % LOOP) + LOOP) % LOOP;
    return mod / LOOP;
  }

  // -----------------------------
  // Non-linear mapping so some segments "hold" longer
  // -----------------------------
  function mapProgressToU(p){
    if (p <= HOLD_P_START) return p;
    if (p >= HOLD_P_END){
      const afterSpanP = 1 - HOLD_P_END;
      const afterSpanU = 1 - HOLD_U;
      const t = (p - HOLD_P_END) / afterSpanP;
      return HOLD_U + t * afterSpanU;
    }
    return HOLD_U;
  }

  // -----------------------------
  // Intro animation state
  // -----------------------------
  let introActive = true;
  let introStart = performance.now();
  const INTRO_MS = 850;

  let lastP = 0;

  // -----------------------------
  // Hint / idle reminder logic
  // -----------------------------
  let lastInputTime = performance.now();
  let hintTimer = null;
  let hintInterval = null;

  function hideHint(){
    scrollHint.classList.remove('play');
    scrollHint.style.opacity = '0';
  }

  function playHint(){
    const p = pFromScroll();
    if (p > 0.30) return;
    scrollHint.style.opacity = '1';
    scrollHint.classList.remove('play');
    void scrollHint.offsetWidth; // restart animation
    scrollHint.classList.add('play');
    setTimeout(() => { hideHint(); }, 950);
  }

  function scheduleHint(){
    if (hintTimer) clearTimeout(hintTimer);
    hintTimer = setTimeout(() => {
      playHint();
      if (!hintInterval){
        hintInterval = setInterval(() => {
          const idle = performance.now() - lastInputTime;
          if (idle >= 2900) playHint();
        }, 3000);
      }
    }, 3000);
  }

  function markInput(){
    lastInputTime = performance.now();
    hideHint();
    scheduleHint();
  }

  // ============================================================
  // RENDERING
  // ============================================================
  function renderWithU(u){
    const vh = window.innerHeight;
    const gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 18;

    // Features panel enters then exits
    const panelIn = easeInOutCubic(clamp01((u - 0.26) / 0.28));
    let panelYpct = lerp(140, 0, panelIn);

    const panelOut = easeInOutCubic(clamp01((u - 0.82) / 0.18));
    panelYpct = lerp(panelYpct, -140, panelOut);

    features.style.transform = `translateY(${panelYpct}%)`;
    featuresGlow.style.transform = `translateY(${lerp(14, -10, panelIn) + lerp(0, -10, panelOut)}px)`;

    // Title anim
    const titleEnter = easeOutCubic(clamp01((u - 0.02) / 0.26));
    const titleExit  = easeInOutCubic(clamp01((u - 0.22) / 0.62));

    let titleY = lerp(vh * 1.25, 0, titleEnter) + lerp(0, -vh * 1.25, titleExit);
    const driftX = Math.sin(u * Math.PI * 2 * 0.9) * 18;
    const driftY = Math.cos(u * Math.PI * 2 * 0.55) * 10;

    const titleHide = easeInOutCubic(clamp01((u - 0.10) / 0.30));
    let titleO = lerp(0.0, 1.0, titleEnter) * lerp(1.0, 0.55, titleHide);

    // Main box anim
    const boxEnter = easeOutCubic(clamp01(u / 0.20));
    const growPhase = easeInOutCubic(clamp01((u - 0.12) / 0.46));
    const escapePhase = easeInOutCubic(clamp01((u - 0.66) / 0.18));

    const trembleAmp = lerp(0.0, 3.2, growPhase) * (1.0 - escapePhase);
    const freq = 16 + 30 * growPhase;
    const jx = Math.sin((u * freq) * Math.PI * 2) * trembleAmp;
    const jy = Math.cos((u * (freq * 0.83)) * Math.PI * 2) * (trembleAmp * 0.55);

    const baseTop = vh * 0.56;
    let centerY = lerp(baseTop + vh * 0.85, baseTop, boxEnter);

    const micro = lerp(12, -10, easeInOutCubic(clamp01((u - 0.18) / 0.48)));
    centerY += micro;

    centerY += lerp(0, -55, panelIn);
    centerY += lerp(0, -vh * 0.80, escapePhase);
    centerY += jy;

    let scale = lerp(0.96, 1.20, growPhase) * lerp(1.0, 0.88, escapePhase);

    // Prevent overlapping features top edge
    const panelTopPx = (panelYpct / 100) * vh;
    const rect = content.getBoundingClientRect();
    const h = rect.height * scale;
    const maxCenterY = panelTopPx - (h / 2) - gapPx;
    if (u > 0.30 && panelYpct < 120){
      centerY = Math.min(centerY, maxCenterY);
    }

    let boxO = lerp(1.0, 0.0, easeInOutCubic(clamp01((u - 0.74) / 0.10)));

    // Hard switch once deep in features
    const inFeaturesHard = (u >= 0.78);
    if (inFeaturesHard){
      titleY = vh * 1.30;
      titleO = 0.0;
      centerY = baseTop + vh * 1.10;
      boxO = 0.0;
    }

    titleTop.style.transform = `translate(-50%, -50%) translate3d(${driftX}px, ${titleY + driftY}px, 0)`;
    titleTop.style.opacity = String(titleO);

    content.style.opacity = String(boxO);
    content.style.transform = `translate(-50%, -50%) translate3d(${jx}px, ${centerY - baseTop}px, 0) scale(${scale})`;

    // Features content stagger
    const a = easeOutCubic(clamp01((u - 0.46) / 0.10));
    const b = easeOutCubic(clamp01((u - 0.52) / 0.12));
    const c = easeOutCubic(clamp01((u - 0.60) / 0.12));

    const fadeOut = easeInOutCubic(clamp01((u - 0.82) / 0.18));
    const keep = 1.0 - fadeOut;

    fMain.style.opacity = String(a * keep);
    fMain.style.transform = `translateY(${(1 - a) * 26 + fadeOut * -36}px)`;

    fGrid.style.opacity = String(b * keep);
    fGrid.style.transform = `translateY(${(1 - b) * 26 + fadeOut * -36}px)`;

    fKeys.style.opacity = String(c * keep);
    fKeys.style.transform = `translateY(${(1 - c) * 26 + fadeOut * -36}px)`;

    const ff = clamp01(panelIn * 1.08);
    fakeFooter.style.opacity = String(ff * keep);
    fakeFooter.style.transform = `translateY(${lerp(12, 0, ff) + fadeOut * -50}px)`;
  }

  function render(){
    const p = pFromScroll();

    // Fade out the whole stage near the end of the loop
    if (p >= FADE_P_START){
      const t = clamp01((p - FADE_P_START) / (FADE_P_END - FADE_P_START));
      stageEl.style.opacity = String(1 - easeInOutCubic(t));
    } else {
      stageEl.style.opacity = "1";
    }

    // Cleanup phase: lock at a stable u to avoid weird pops
    if (p >= CLEANUP_P_START){
      renderWithU(0.80);
      return;
    }

    const u = mapProgressToU(p);
    renderWithU(u);
  }

  // ============================================================
  // INPUT (FIXED)
  // ------------------------------------------------------------
  // We DO NOT listen on #inputLayer anymore because it is
  // click-through (pointer-events:none) and should not capture input.
  // So we listen on window instead.
  // ============================================================
  function normalizeWheelDelta(e){
    let dy = e.deltaY;
    if (e.deltaMode === 1) dy *= 16;               // lines -> px
    else if (e.deltaMode === 2) dy *= window.innerHeight; // pages -> px
    return dy;
  }

  window.addEventListener('wheel', (e) => {
    e.preventDefault(); // required to avoid browser scrolling
    markInput();
    if (introActive) return;

    const dy = normalizeWheelDelta(e);
    const impulse = Math.max(-MAX_IMPULSE, Math.min(MAX_IMPULSE, dy * WHEEL_SCALE));
    vVel += impulse * RESPONSE;
  }, { passive: false });

  let touchActive = false;
  let lastY = 0;

  window.addEventListener('touchstart', (e) => {
    if (e.touches && e.touches[0]){
      touchActive = true;
      lastY = e.touches[0].clientY;
    }
  }, { passive: true });

  window.addEventListener('touchmove', (e) => {
    if (!touchActive) return;
    if (e.touches && e.touches[0]){
      e.preventDefault(); // required to prevent page scroll
      markInput();
      if (introActive) return;

      const y = e.touches[0].clientY;
      const dy = lastY - y;
      lastY = y;

      const impulse = Math.max(-MAX_IMPULSE, Math.min(MAX_IMPULSE, dy * TOUCH_SCALE));
      vVel += impulse * RESPONSE;
    }
  }, { passive: false });

  window.addEventListener('touchend', () => { touchActive = false; }, { passive: true });
  window.addEventListener('touchcancel', () => { touchActive = false; }, { passive: true });

  // Keyboard input
  window.addEventListener('keydown', (e) => {
    if (introActive) return;
    if (e.key === 'ArrowDown' || e.key === 'PageDown' || e.key === ' '){
      markInput();
      vVel += KEY_STEP;
    } else if (e.key === 'ArrowUp' || e.key === 'PageUp'){
      markInput();
      vVel -= KEY_STEP;
    }
  });

  // ============================================================
  // MAIN TICK LOOP
  // ============================================================
  let last = performance.now();

  function startIntro(now){
    introActive = true;
    introStart = now;
    vVel = 0;
    stageEl.style.opacity = "1";
  }

  function tick(now){
    const dt = Math.min(40, now - last);
    last = now;

    const p = pFromScroll();

    // Wrap later (once really out) to avoid popping
    if (!introActive && lastP > 0.97 && p < 0.06){
      vScroll = 0;
      startIntro(now);
    }
    lastP = p;

    // Intro sequence: "auto-play" into first state
    if (introActive){
      const t = clamp01((now - introStart) / INTRO_MS);
      const e = easeOutCubic(t);
      const u = lerp(0.00, 0.12, e);
      renderWithU(u);

      if (t >= 1){
        introActive = false;
        vScroll = 0.12 * LOOP;
        scheduleHint();
      }

      requestAnimationFrame(tick);
      return;
    }

    // Integrate velocity -> scroll
    vScroll += vVel;

    // Apply friction (frame-rate independent-ish)
    vVel *= Math.pow(0.86, dt / 16);

    // Keep numbers bounded
    if (vScroll > 1e12) vScroll = vScroll % LOOP;
    if (vScroll < -1e12) vScroll = -((-vScroll) % LOOP);

    render();
    requestAnimationFrame(tick);
  }

  computeLoopLen();
  window.addEventListener('resize', () => { computeLoopLen(); });

  startIntro(performance.now());
  requestAnimationFrame(tick);

  // ============================================================
  // TOOL LOGIC (JSZip + Image splitting)
  // ============================================================
  let zip = new JSZip();
  let latestParts = [];

  // Drag & drop events
  dropZone.addEventListener('dragover', (e) => {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    dropZone.classList.add('over');
  });

  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('over');
  });

  dropZone.addEventListener('drop', (e) => {
    e.stopPropagation();
    e.preventDefault();
    dropZone.classList.remove('over');
    const files = e.dataTransfer.files;
    if (files.length > 0) processFile(files[0]);
  });

  // File input change
  uploadButton.addEventListener('change', function(e) {
    if (e.target.files.length > 0) processFile(e.target.files[0]);
  });

  function processFile(file) {
    previewContainer.innerHTML = '';
    previewContainer.style.display = 'none';
    downloadContainer.innerHTML = '';
    zip = new JSZip();
    latestParts = [];
    partitionImage(file);
    downloadButton.style.display = 'inline-block';
  }

  // Draw image in "cover" mode: always fills the target area
  function drawCover(ctx, img, dx, dy, dw, dh) {
    const sw = img.width;
    const sh = img.height;
    const scale = Math.max(dw / sw, dh / sh);
    const cw = dw / scale;
    const ch = dh / scale;
    const sx = (sw - cw) / 2;
    const sy = (sh - ch) / 2;
    ctx.drawImage(img, sx, sy, cw, ch, dx, dy, dw, dh);
  }

  // Trigger a download of a blob
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(function() { URL.revokeObjectURL(url); }, 60000);
  }

  function partitionImage(file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      const img = new Image();
      img.onload = function() {
        // Instagram tile size
        const TILE_W = 1080;
        const TILE_H = 1350;

        // Visible part in the profile grid when IG crops to square:
        // grid ratio = 3:4 in height terms for 4:5 posts
        const GRID_RATIO = 3 / 4;
        let visibleW = Math.round(TILE_H * GRID_RATIO);

        // Bleed on each side
        let bleed = (TILE_W - visibleW) / 2;

        // Ensure integer bleed to avoid subpixel seams
        if (!Number.isInteger(bleed)) {
          const try1 = (TILE_W - (visibleW - 1)) / 2;
          const try2 = (TILE_W - (visibleW + 1)) / 2;
          if (Number.isInteger(try1)) { visibleW -= 1; bleed = try1; }
          else if (Number.isInteger(try2)) { visibleW += 1; bleed = try2; }
          else { bleed = Math.floor(bleed); visibleW = TILE_W - 2 * bleed; }
        }

        // Master canvas is exactly the visible 3 tiles side-by-side
        const MASTER_W = visibleW * 3;
        const MASTER_H = TILE_H;

        const masterCanvas = document.createElement("canvas");
        const mctx = masterCanvas.getContext("2d");
        masterCanvas.width = MASTER_W;
        masterCanvas.height = MASTER_H;

        mctx.imageSmoothingEnabled = true;
        mctx.imageSmoothingQuality = "high";

        // Fit original image into master canvas (cover)
        drawCover(mctx, img, 0, 0, MASTER_W, MASTER_H);

        // Show preview container
        previewContainer.innerHTML = "";
        previewContainer.style.display = "flex";

        // Show posting hint
        publishWarning.classList.remove("show");
        setTimeout(() => { publishWarning.classList.add("show"); }, 100);

        // Create 3 tiles
        for (let i = 0; i < 3; i++) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          canvas.width = TILE_W;
          canvas.height = TILE_H;

          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          const srcXVisible = i * visibleW;

          // Draw the visible region in the center of the tile
          ctx.drawImage(masterCanvas, srcXVisible, 0, visibleW, TILE_H, bleed, 0, visibleW, TILE_H);

          // Fill left bleed by copying from master canvas (or wrapping)
          const leftSrcX = Math.max(srcXVisible - bleed, 0);
          const leftSrcW = srcXVisible - leftSrcX;

          if (leftSrcW > 0) {
            ctx.drawImage(masterCanvas, leftSrcX, 0, leftSrcW, TILE_H, bleed - leftSrcW, 0, leftSrcW, TILE_H);
          }

          const missingLeft = bleed - leftSrcW;
          if (missingLeft > 0) {
            ctx.drawImage(masterCanvas, srcXVisible, 0, missingLeft, TILE_H, 0, 0, missingLeft, TILE_H);
          }

          // Fill right bleed by copying from master canvas (or wrapping)
          const rightEdge = srcXVisible + visibleW;
          const rightSrcX = Math.min(rightEdge, MASTER_W);
          const rightAvailable = Math.max(0, MASTER_W - rightSrcX);
          const rightSrcW = Math.min(bleed, rightAvailable);

          if (rightSrcW > 0) {
            ctx.drawImage(masterCanvas, rightSrcX, 0, rightSrcW, TILE_H, bleed + visibleW, 0, rightSrcW, TILE_H);
          }

          const missingRight = bleed - rightSrcW;
          if (missingRight > 0) {
            ctx.drawImage(masterCanvas, rightEdge - missingRight, 0, missingRight, TILE_H, bleed + visibleW + rightSrcW, 0, missingRight, TILE_H);
          }

          // Create preview image
          const dataURL = canvas.toDataURL("image/png");
          const previewImg = new Image();
          previewImg.src = dataURL;

          const wrap = document.createElement("div");
          wrap.className = "preview-tile";
          wrap.appendChild(previewImg);

          const filename = `partition_${i + 1}.png`;

          // Convert to blob + add to zip + enable per-tile download
          canvas.toBlob(function(blob) {
            latestParts.push({ index: i + 1, blob: blob, filename: filename });
            zip.file(filename, blob);

            wrap.addEventListener("click", function() {
              downloadBlob(blob, filename);
            });
          }, "image/png");

          previewContainer.appendChild(wrap);
        }
      };

      img.src = e.target.result;
    };

    reader.readAsDataURL(file);
  }

  function downloadZip() {
    downloadButton.disabled = true;
    downloadButton.textContent = "Preparing ZIP...";

    zip.generateAsync({ type: "blob", compression: "STORE" })
      .then(function(blob) {
        const url = URL.createObjectURL(blob);

        const existingLink = document.getElementById("zipDownloadLink");
        if (existingLink) existingLink.remove();

        const a = document.createElement("a");
        a.id = "zipDownloadLink";
        a.href = url;
        a.download = "partitions.zip";
        a.textContent = "Download partitions.zip";
        a.className = "download-link";

        downloadContainer.innerHTML = "";
        downloadContainer.appendChild(a);

        downloadButton.disabled = false;
        downloadButton.textContent = "Generate ZIP";

        setTimeout(function() { URL.revokeObjectURL(url); }, 60000);
      })
      .catch(function(error) {
        console.error("ZIP generation error:", error);
        downloadButton.disabled = false;
        downloadButton.textContent = "Generate ZIP";
        alert("Error while generating the ZIP.");
      });
  }

  downloadButton.addEventListener('click', downloadZip);
});
</script>

</body>
</html>
