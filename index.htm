<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>INSTACUT</title>

  <!-- JSZip library for creating ZIP files -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>

  <style>
/* ===================================================== */
/* ===================== GLOBAL ======================== */
/* ===================================================== */

:root{
  --bg0:#07070b;
  --bg1:#0a0d16;
  --glass: rgba(255,255,255,0.06);
  --glass2: rgba(255,255,255,0.10);
  --stroke: rgba(255,255,255,0.16);
  --ink: rgba(255,255,255,0.92);
  --muted: rgba(255,255,255,0.68);

  --a:#a7cbd9;   /* original accent */
  --b:#6faec7;
  --c:#b3ffb3;   /* pulse green */
  --d:#a88bff;   /* cyber purple */
}

*{ box-sizing: border-box; }

body {
  margin: 0;
  min-height: 100vh;
  font-family: Arial, sans-serif;
  color: var(--ink);
  background:
    radial-gradient(1200px 700px at 20% 10%, rgba(168,139,255,0.20), transparent 60%),
    radial-gradient(900px 600px at 80% 20%, rgba(167,203,217,0.18), transparent 60%),
    radial-gradient(1000px 700px at 50% 90%, rgba(179,255,179,0.12), transparent 60%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
  overflow-x: hidden;
}

/* Subtle scan/grain overlay (no drop-shadows) */
body::before{
  content:"";
  position: fixed;
  inset: 0;
  pointer-events: none;
  background-image:
    linear-gradient(90deg, rgba(255,255,255,0.015), rgba(255,255,255,0.015)),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02) 1px, rgba(0,0,0,0) 1px, rgba(0,0,0,0) 3px);
  mix-blend-mode: overlay;
  opacity: 0.45;
}

/* ===================================================== */
/* ===================== TITLE TOP ===================== */
/* ===================================================== */

.title-top {
  position: relative;
  z-index: 0;
  font-size: 17vw;
  font-weight: 900;
  letter-spacing: 0.03em;
  color: rgba(255,255,255,0.05);
  overflow: hidden;
  user-select: none;
  text-align: center;
  line-height: 0.9;
  margin-top: 1vh;
}

/* ===================================================== */
/* ===================== CONTENT ======================= */
/* ===================================================== */

.content{
  position: relative;
  z-index: 1;
  width: min(980px, 92vw);
  margin: 0 auto;
  margin-top: -20%;
  padding: 28px 22px 34px;
  border-radius: 22px;

  background: linear-gradient(180deg, var(--glass2), var(--glass));
  border: 1px solid var(--stroke);
  backdrop-filter: blur(16px);

  transition: margin-top 0.35s ease;
  will-change: margin-top;
}

/* Page entrance animation: content slides into place */
.content.enter {
  animation: slideIn 650ms cubic-bezier(.2,.9,.2,1) 1;
}
@keyframes slideIn{
  from { transform: translateY(18px); opacity: 0.0; }
  to   { transform: translateY(0);    opacity: 1.0; }
}

/* Decorative sigil glow layers (still no shadows) */
.sigil {
  position: absolute;
  inset: -1px;
  border-radius: 22px;
  pointer-events: none;
  background:
    radial-gradient(600px 140px at 50% 0%, rgba(167,203,217,0.25), transparent 70%),
    radial-gradient(500px 120px at 30% 100%, rgba(168,139,255,0.18), transparent 70%),
    radial-gradient(380px 110px at 80% 85%, rgba(179,255,179,0.10), transparent 70%);
  mask-image: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.15));
  opacity: 0.9;
}


.publish-warning{
  margin: 14px auto 4px;
  padding: 12px 16px;
  border-radius: 14px;
  border: 1px solid rgba(179,255,179,0.35);
  background: linear-gradient(
    135deg,
    rgba(179,255,179,0.08),
    rgba(167,203,217,0.08)
  );
  font-size: 0.9rem;
  line-height: 1.5;
  color: var(--muted);
  text-align: center;

  opacity: 0;
  transform: translateX(-40px);
  transition: transform 400ms cubic-bezier(.2,.9,.2,1), 
              opacity 400ms ease;
}

.publish-warning.show{
  opacity: 1;
  transform: translateX(0);
}


/* ===================================================== */
/* ================== DROP ZONE ======================== */
/* ===================================================== */

.drop-zone {
  position: relative;
  border-radius: 18px;
  padding: 28px 18px;
  margin: 18px auto 10px;
  border: 1px dashed rgba(167,203,217,0.55);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  cursor: pointer;
  overflow: hidden;
}

/* The file input covers the whole zone so click/drop works anywhere */
.drop-zone input[type="file"]{
  position: absolute;
  inset: 0;
  opacity: 0;
  cursor: pointer;
}

/* Drop zone text */
.drop-hint{
  display: grid;
  gap: 10px;
  justify-items: center;
  padding: 10px 0;
}

.drop-hint .kicker{
  font-size: 0.95rem;
  color: var(--muted);
  letter-spacing: 0.02em;
}

.drop-hint .cta{
  display: inline-flex;
  align-items: center;
  gap: 10px;
  padding: 12px 18px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.14);
  background: linear-gradient(135deg, rgba(167,203,217,0.18), rgba(168,139,255,0.12));
}

/* Drag-over scan effect */
.drop-zone.over::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(900px 220px at 50% 10%, rgba(179,255,179,0.16), transparent 70%),
    linear-gradient(90deg, transparent, rgba(167,203,217,0.12), transparent);
  animation: sweep 1.1s linear infinite;
  pointer-events: none;
}
@keyframes sweep{
  0%   { transform: translateX(-25%); opacity: 0.55; }
  50%  { transform: translateX(0%);   opacity: 0.80; }
  100% { transform: translateX(25%);  opacity: 0.55; }
}

.drop-zone.over{
  border-color: rgba(179,255,179,0.75);
}

/* ===================================================== */
/* ===================== BUTTONS ======================= */
/* ===================================================== */

/* Buttons intentionally avoid drop shadows */
#downloadButton {
  padding: 12px 18px;
  font-size: 1rem;
  font-weight: 700;
  border: 1px solid rgba(255,255,255,0.16);
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(167,203,217,0.26), rgba(111,174,199,0.18));
  color: var(--ink);
  cursor: pointer;

  box-shadow: none !important;
  filter: none !important;

  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}

#downloadButton:hover{
  transform: translateY(-1px);
  border-color: rgba(167,203,217,0.55);
  background: linear-gradient(135deg, rgba(167,203,217,0.32), rgba(168,139,255,0.16));
}

#downloadButton:disabled{
  opacity: 0.65;
  cursor: not-allowed;
  transform: none;
}

.zip-button-wrapper{
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 14px;
}

/* ===================================================== */
/* ===================== PREVIEW ======================= */
/* ===================================================== */

#previewContainer {
  position: relative;
  width: min(900px, 92vw);
  margin: 18px auto 10px;
  padding: 14px;
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(255,255,255,0.03);
  backdrop-filter: blur(10px);
  display: none; /* Initially hidden */
  justify-content: center;
  align-items: center;
  gap: 10px;
  overflow: hidden;
}

/* Diagonal hatch overlay */
#previewContainer::after{
  content:'';
  position:absolute;
  inset:0;
  background-image: repeating-linear-gradient(
    -45deg,
    rgba(255,255,255,0.00),
    rgba(255,255,255,0.00) 12px,
    rgba(255,255,255,0.06) 12px,
    rgba(255,255,255,0.06) 18px
  );
  pointer-events:none;
  opacity: 0.45;
}

/* Clickable preview wrapper */
.preview-tile {
  position: relative;
  display: inline-flex;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.12);
  overflow: hidden;
  cursor: pointer;
  user-select: none;

  box-shadow: none;
  background: rgba(255,255,255,0.02);

  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}

.preview-tile:hover{
  transform: translateY(-1px);
  border-color: rgba(179,255,179,0.45);
  background: rgba(255,255,255,0.04);
}

/* Tiny hint overlay shown on hover */
.preview-tile::after{
  content: "Download";
  position: absolute;
  right: 10px;
  bottom: 10px;
  font-size: 0.85rem;
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(10,13,22,0.55);
  color: rgba(255,255,255,0.90);
  opacity: 0;
  transform: translateY(4px);
  transition: opacity 160ms ease, transform 160ms ease;
  pointer-events: none;
}

.preview-tile:hover::after{
  opacity: 1;
  transform: translateY(0);
}

/* Preview images */
#previewContainer img {
  height: 200px;
  display: block;
  box-shadow: none;
}

/* ===================================================== */
/* ================= DOWNLOAD LINK ===================== */
/* ===================================================== */

.download-container{
  width: 100%;
  display: flex;
  justify-content: center;
  margin-top: 14px;
}

/* Styled download link (no shadows) */
.download-link{
  display: inline-flex;
  align-items: center;
  gap: 10px;

  padding: 12px 18px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.16);
  text-decoration: none;
  color: var(--ink);
  background: linear-gradient(135deg, rgba(168,139,255,0.18), rgba(167,203,217,0.20));
  box-shadow: none !important;
  filter: none !important;

  transition: transform 180ms ease, border-color 180ms ease, background 180ms ease;
}

.download-link:hover{
  transform: translateY(-1px);
  border-color: rgba(179,255,179,0.50);
  background: linear-gradient(135deg, rgba(179,255,179,0.14), rgba(167,203,217,0.22));
}

/* ===================================================== */
/* ===================== SMALL TEXT ==================== */
/* ===================================================== */

.helper{
  margin-top: 10px;
  color: var(--muted);
  font-size: 0.95rem;
}
  </style>
</head>

<body>
  <div class="title-top">INSTACUT</div>

  <div class="content">
    <div class="sigil"></div>

    <!-- Drag & drop zone for image upload -->
    <div class="drop-zone" id="dropZone">
      <div class="drop-hint">
        <div class="cta">
          <span>Drop an image here</span>
          <span style="opacity:.7">or click</span>
        </div>
        <div class="kicker">Split into 3 posts (Instagram grid anti-zoom)</div>
      </div>
      <input type="file" id="uploadButton" accept="image/*" />
    </div>

    <!-- Button used to generate the ZIP file -->
    <div class="zip-button-wrapper">
      <button id="downloadButton" style="display: none;">Generate ZIP</button>
    </div>

    <!-- Container that will display preview images -->
    <div id="previewContainer"></div>

    <div class="publish-warning" id="publishWarning">
     ⚠️ Instagram defaults to square, tap ⤢ EXPAND when posting. ⚠️
    </div>


    <!-- Container that will receive the real download link -->
    <div class="download-container" id="downloadContainer"></div>
  </div>

  <script>
document.addEventListener('DOMContentLoaded', function() {

  // ==============================
  // DOM references
  // ==============================
  const content = document.querySelector('.content');
  const dropZone = document.getElementById('dropZone');
  const uploadButton = document.getElementById('uploadButton');
  const previewContainer = document.getElementById('previewContainer');
  const downloadButton = document.getElementById('downloadButton');
  const downloadContainer = document.getElementById('downloadContainer');

  // ==============================
  // ZIP (JSZip)
  // ==============================
  let zip = new JSZip();

  // Exported blobs for direct download via thumbnail click
  let latestParts = []; // [{ index: 1..3, blob: Blob, filename: string }]

  // ==============================
  // Entrance animation
  // ==============================
  setTimeout(function() {
    content.classList.add('enter');
    content.style.marginTop = '-8%';
  }, 80);

  // ==============================
  // Drag & drop
  // ==============================
  dropZone.addEventListener('dragover', (e) => {
    e.stopPropagation();
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
    dropZone.classList.add('over');
  });

  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('over');
  });

  dropZone.addEventListener('drop', (e) => {
    e.stopPropagation();
    e.preventDefault();
    dropZone.classList.remove('over');

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      processFile(files[0]);
    }
  });

  // File selection via input
  uploadButton.addEventListener('change', function(e) {
    if (e.target.files.length > 0) {
      processFile(e.target.files[0]);
    }
  });

  // ==============================
  // File processing
  // ==============================
  function processFile(file) {
    // Reset UI & data for a new file
    previewContainer.innerHTML = '';
    previewContainer.style.display = 'none';
    downloadContainer.innerHTML = '';
    zip = new JSZip();
    latestParts = [];

    // Start slicing
    partitionImage(file);

    // Show ZIP button (it will generate a real <a download> link)
    downloadButton.style.display = 'inline-block';
  }

  // =====================================================
  // Image helpers
  // =====================================================

  // Draws an image like CSS background-size: cover
  // Fills the target area without letterboxing, cropping from the center if needed.
  function drawCover(ctx, img, dx, dy, dw, dh) {
    const sw = img.width;
    const sh = img.height;

    const scale = Math.max(dw / sw, dh / sh);
    const cw = dw / scale;
    const ch = dh / scale;

    const sx = (sw - cw) / 2;
    const sy = (sh - ch) / 2;

    ctx.drawImage(img, sx, sy, cw, ch, dx, dy, dw, dh);
  }

  // Downloads a blob (used when clicking a thumbnail)
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;

    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(function() {
      URL.revokeObjectURL(url);
    }, 60000);
  }

  // =====================================================
  // Partitioning logic
  // =====================================================

  /*
    Posting note:
    Exported tiles are 1080x1350 (4:5). Instagram profile grids typically crop
    posts to a narrower portrait preview (around 3:4). This tool generates tiles
    with safe “bleed” areas so the grid looks continuous across 3 posts.

    Publishing guidance:
    Ensure each tile is posted as a full 4:5 image. Instagram may preview in a square
    or apply additional cropping in some contexts; avoiding extra edits/resizing helps
    prevent visible misalignment in the profile grid. If a warning is displayed in the UI,
    keep it clear and noticeable while preserving a clean, pleasant layout (avoid harsh,
    intrusive placement).
  */

  function partitionImage(file) {
    const reader = new FileReader();

    reader.onload = function(e) {
      const img = new Image();

      img.onload = function() {
        // =====================================================
        // 1) Instagram parameters (post export + grid behavior)
        // =====================================================

        // Post export size (portrait 4:5)
        const TILE_W = 1080;
        const TILE_H = 1350;

        // Profile grid visible area ratio (approx. 3:4 portrait => width/height ~ 0.75)
        const GRID_RATIO = 3 / 4; // ~0.75

        // Visible grid width for a TILE_H height
        // 1350 * 0.75 = 1012.5 => round, then adjust to keep an integer bleed.
        let visibleW = Math.round(TILE_H * GRID_RATIO);

        // Enforce an integer symmetric bleed:
        // bleed = (1080 - visibleW)/2 must be an integer.
        let bleed = (TILE_W - visibleW) / 2;
        if (!Number.isInteger(bleed)) {
          // Try visibleW-1 or visibleW+1 to obtain an integer bleed.
          const try1 = (TILE_W - (visibleW - 1)) / 2;
          const try2 = (TILE_W - (visibleW + 1)) / 2;

          if (Number.isInteger(try1)) {
            visibleW = visibleW - 1;
            bleed = try1;
          } else if (Number.isInteger(try2)) {
            visibleW = visibleW + 1;
            bleed = try2;
          } else {
            // Fallback: floor the bleed and recompute visible width
            bleed = Math.floor(bleed);
            visibleW = TILE_W - 2 * bleed;
          }
        }

        // Master "grid-visible" canvas across 3 tiles (continuous content)
        const MASTER_W = visibleW * 3;
        const MASTER_H = TILE_H;

        // =====================================================
        // 2) Build the master (cover-fit first, no letterboxing)
        // =====================================================
        const masterCanvas = document.createElement("canvas");
        const mctx = masterCanvas.getContext("2d");

        masterCanvas.width = MASTER_W;
        masterCanvas.height = MASTER_H;

        // Resampling quality
        mctx.imageSmoothingEnabled = true;
        mctx.imageSmoothingQuality = "high";

        // Cover-fill MASTER_W x MASTER_H (center crop if needed)
        drawCover(mctx, img, 0, 0, MASTER_W, MASTER_H);

        // =====================================================
        // 3) Cut into 3 tiles (1080x1350)
        //    - keep the visible area centered (x = bleed)
        //    - fill bleed by continuity from the master (no 1px stretching)
        // =====================================================

        previewContainer.innerHTML = "";
        previewContainer.style.display = "flex";
        const publishWarning = document.getElementById("publishWarning");
        publishWarning.classList.remove("show");

        setTimeout(() => {
          publishWarning.classList.add("show");
        }, 100);

        for (let i = 0; i < 3; i++) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");

          canvas.width = TILE_W;
          canvas.height = TILE_H;

          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          // Source X of the visible area inside the master
          const srcXVisible = i * visibleW;

          // a) Visible area centered in the tile
          ctx.drawImage(
            masterCanvas,
            srcXVisible, 0, visibleW, TILE_H,
            bleed, 0, visibleW, TILE_H
          );

          // b) Left bleed: copy pixels from the left side of the visible area
          const leftSrcX = Math.max(srcXVisible - bleed, 0);
          const leftSrcW = srcXVisible - leftSrcX;

          if (leftSrcW > 0) {
            ctx.drawImage(
              masterCanvas,
              leftSrcX, 0, leftSrcW, TILE_H,
              bleed - leftSrcW, 0, leftSrcW, TILE_H
            );
          }

          // If still missing (first tile edge), complete using adjacent pixels (no smearing)
          const missingLeft = bleed - leftSrcW;
          if (missingLeft > 0) {
            ctx.drawImage(
              masterCanvas,
              srcXVisible, 0, missingLeft, TILE_H,
              0, 0, missingLeft, TILE_H
            );
          }

          // c) Right bleed: same logic on the right side
          const rightEdge = srcXVisible + visibleW;
          const rightSrcX = Math.min(rightEdge, MASTER_W);
          const rightAvailable = Math.max(0, MASTER_W - rightSrcX);
          const rightSrcW = Math.min(bleed, rightAvailable);

          if (rightSrcW > 0) {
            ctx.drawImage(
              masterCanvas,
              rightSrcX, 0, rightSrcW, TILE_H,
              bleed + visibleW, 0, rightSrcW, TILE_H
            );
          }

          const missingRight = bleed - rightSrcW;
          if (missingRight > 0) {
            ctx.drawImage(
              masterCanvas,
              rightEdge - missingRight, 0, missingRight, TILE_H,
              bleed + visibleW + rightSrcW, 0, missingRight, TILE_H
            );
          }

          // =====================================================
          // 4) Preview + export PNG + ZIP
          // =====================================================
          const dataURL = canvas.toDataURL("image/png");
          const previewImg = new Image();
          previewImg.src = dataURL;

          const wrap = document.createElement("div");
          wrap.className = "preview-tile";
          wrap.appendChild(previewImg);

          const filename = `partition_${i + 1}.png`;

          canvas.toBlob(function(blob) {
            latestParts.push({ index: i + 1, blob: blob, filename: filename });
            zip.file(filename, blob);

            wrap.addEventListener("click", function() {
              downloadBlob(blob, filename);
            });
          }, "image/png");

          previewContainer.appendChild(wrap);
        }
      };

      img.src = e.target.result;
    };

    reader.readAsDataURL(file);
  }

  // =====================================================
  // ZIP download (generates a real <a download> link)
  // =====================================================
  function downloadZip() {
    downloadButton.disabled = true;
    downloadButton.textContent = "Preparing ZIP...";

    zip.generateAsync({
      type: "blob",
      compression: "STORE"
    }).then(function(blob) {

      const url = URL.createObjectURL(blob);

      const existingLink = document.getElementById("zipDownloadLink");
      if (existingLink) {
        existingLink.remove();
      }

      const a = document.createElement("a");
      a.id = "zipDownloadLink";
      a.href = url;
      a.download = "partitions.zip";
      a.textContent = "Download partitions.zip";
      a.className = "download-link";

      downloadContainer.innerHTML = "";
      downloadContainer.appendChild(a);

      downloadButton.disabled = false;
      downloadButton.textContent = "Generate ZIP";

      setTimeout(function() {
        URL.revokeObjectURL(url);
      }, 60000);

    }).catch(function(error) {

      console.error("ZIP generation error:", error);

      downloadButton.disabled = false;
      downloadButton.textContent = "Generate ZIP";

      alert("Error while generating the ZIP.");
    });
  }

  downloadButton.addEventListener('click', downloadZip);

  // Cosmetic scroll animation
  window.addEventListener('scroll', function() {
    const scrollPercentage = window.scrollY / window.innerHeight;
    let newMarginTop = -8 - (scrollPercentage * 12);
    newMarginTop = Math.max(-20, Math.min(-3, newMarginTop));
    content.style.marginTop = newMarginTop + '%';
  });

});
  </script>
</body>
</html>
